//! Unified SQLite storage for the application.
//!
//! Single database containing:
//! - Sessions and messages (AI chat conversations)
//! - Projects and artifacts (persistent outputs)

use rusqlite::{params, Connection, OptionalExtension};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use std::sync::Mutex;

// =============================================================================
// Session Types
// =============================================================================

/// A session (conversation with an AI agent)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Session {
    pub id: String,
    pub working_dir: String,
    pub agent_id: String,
    pub title: Option<String>,
    pub created_at: i64,
    pub updated_at: i64,
}

/// A message in a session
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Message {
    pub id: i64,
    pub session_id: String,
    pub role: MessageRole,
    /// For user messages: plain text
    /// For assistant messages: JSON array of ContentSegment
    pub content: String,
    pub created_at: i64,
}

/// A segment of assistant content (text or tool call), stored in order
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum ContentSegment {
    Text {
        text: String,
    },
    ToolCall {
        id: String,
        title: String,
        status: String,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        locations: Vec<String>,
    },
}

/// Message role
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum MessageRole {
    User,
    Assistant,
}

impl MessageRole {
    pub fn as_str(&self) -> &'static str {
        match self {
            MessageRole::User => "user",
            MessageRole::Assistant => "assistant",
        }
    }

    pub fn parse(s: &str) -> Self {
        match s {
            "user" => MessageRole::User,
            _ => MessageRole::Assistant,
        }
    }
}

/// Full session with messages
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct SessionFull {
    pub session: Session,
    pub messages: Vec<Message>,
}

// =============================================================================
// Project Types
// =============================================================================

/// The generation status of an artifact.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum ArtifactStatus {
    /// Artifact is being generated by AI
    Generating,
    /// Artifact generation completed successfully
    #[default]
    Complete,
    /// Artifact generation failed
    Error,
}

impl ArtifactStatus {
    pub fn as_str(&self) -> &'static str {
        match self {
            ArtifactStatus::Generating => "generating",
            ArtifactStatus::Complete => "complete",
            ArtifactStatus::Error => "error",
        }
    }

    pub fn parse(s: &str) -> Self {
        match s {
            "generating" => ArtifactStatus::Generating,
            "error" => ArtifactStatus::Error,
            _ => ArtifactStatus::Complete,
        }
    }
}

/// A goal-oriented collection of artifacts.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Project {
    pub id: String,
    pub name: String,
    pub created_at: i64,
    pub updated_at: i64,
}

impl Project {
    pub fn new(name: impl Into<String>) -> Self {
        let now = now_timestamp();
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            name: name.into(),
            created_at: now,
            updated_at: now,
        }
    }
}

/// The type of an artifact.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ArtifactType {
    Markdown,
    Commit,
}

impl ArtifactType {
    pub fn as_str(&self) -> &'static str {
        match self {
            ArtifactType::Markdown => "markdown",
            ArtifactType::Commit => "commit",
        }
    }
}

/// Type-specific data for an artifact.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ArtifactData {
    Markdown {
        content: String,
    },
    Commit {
        repo: String,
        branch: String,
        #[serde(rename = "commitSha")]
        commit_sha: String,
    },
}

impl ArtifactData {
    pub fn artifact_type(&self) -> ArtifactType {
        match self {
            ArtifactData::Markdown { .. } => ArtifactType::Markdown,
            ArtifactData::Commit { .. } => ArtifactType::Commit,
        }
    }
}

/// The persistent output of AI work.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Artifact {
    pub id: String,
    pub project_id: String,
    pub title: String,
    pub created_at: i64,
    pub updated_at: i64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_artifact_id: Option<String>,
    /// The type-specific data (markdown content, commit info, etc.)
    pub data: ArtifactData,
    /// Generation status (generating, complete, error)
    #[serde(default)]
    pub status: ArtifactStatus,
    /// Error message if status is Error
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_message: Option<String>,
    /// Session ID for viewing the generation conversation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,
}

impl Artifact {
    /// Create a new markdown artifact.
    pub fn new_markdown(
        project_id: impl Into<String>,
        title: impl Into<String>,
        content: impl Into<String>,
    ) -> Self {
        let now = now_timestamp();
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            project_id: project_id.into(),
            title: title.into(),
            created_at: now,
            updated_at: now,
            parent_artifact_id: None,
            data: ArtifactData::Markdown {
                content: content.into(),
            },
            status: ArtifactStatus::Complete,
            error_message: None,
            session_id: None,
        }
    }

    /// Create a new markdown artifact in generating state.
    pub fn new_generating(project_id: impl Into<String>, title: impl Into<String>) -> Self {
        let now = now_timestamp();
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            project_id: project_id.into(),
            title: title.into(),
            created_at: now,
            updated_at: now,
            parent_artifact_id: None,
            data: ArtifactData::Markdown {
                content: String::new(),
            },
            status: ArtifactStatus::Generating,
            error_message: None,
            session_id: None,
        }
    }

    /// Get the artifact type.
    pub fn artifact_type(&self) -> ArtifactType {
        self.data.artifact_type()
    }
}

// =============================================================================
// Error type
// =============================================================================

#[derive(Debug)]
pub struct StoreError(pub String);

impl StoreError {
    pub fn new(msg: impl Into<String>) -> Self {
        Self(msg.into())
    }
}

impl std::fmt::Display for StoreError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl std::error::Error for StoreError {}

impl From<rusqlite::Error> for StoreError {
    fn from(e: rusqlite::Error) -> Self {
        StoreError(e.to_string())
    }
}

impl From<serde_json::Error> for StoreError {
    fn from(e: serde_json::Error) -> Self {
        StoreError(e.to_string())
    }
}

pub type Result<T> = std::result::Result<T, StoreError>;

// =============================================================================
// Store
// =============================================================================

/// Unified SQLite-backed storage
pub struct Store {
    conn: Mutex<Connection>,
}

impl Store {
    /// Open or create the database at the given path
    pub fn open(db_path: PathBuf) -> Result<Self> {
        // Ensure parent directory exists
        if let Some(parent) = db_path.parent() {
            std::fs::create_dir_all(parent)
                .map_err(|e| StoreError::new(format!("Cannot create directory: {}", e)))?;
        }

        let conn = Connection::open(&db_path)?;

        // Enable foreign keys immediately on connection open
        conn.execute("PRAGMA foreign_keys = ON", [])?;

        let store = Self {
            conn: Mutex::new(conn),
        };
        store.init_schema()?;
        Ok(store)
    }

    /// Initialize the database schema
    fn init_schema(&self) -> Result<()> {
        let conn = self.conn.lock().unwrap();

        conn.execute_batch(
            r#"
            -- =================================================================
            -- Sessions (AI chat conversations)
            -- =================================================================

            CREATE TABLE IF NOT EXISTS sessions (
                id TEXT PRIMARY KEY,
                working_dir TEXT NOT NULL,
                agent_id TEXT NOT NULL,
                title TEXT,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL
            );

            CREATE TABLE IF NOT EXISTS messages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                session_id TEXT NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
                role TEXT NOT NULL,
                content TEXT NOT NULL,
                created_at INTEGER NOT NULL
            );

            CREATE INDEX IF NOT EXISTS idx_messages_session ON messages(session_id);
            CREATE INDEX IF NOT EXISTS idx_sessions_updated ON sessions(updated_at DESC);

            -- =================================================================
            -- Projects and Artifacts
            -- =================================================================

            CREATE TABLE IF NOT EXISTS projects (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL
            );

            CREATE TABLE IF NOT EXISTS artifacts (
                id TEXT PRIMARY KEY,
                project_id TEXT NOT NULL,
                title TEXT NOT NULL,
                artifact_type TEXT NOT NULL,
                data_json TEXT NOT NULL,
                created_at INTEGER NOT NULL,
                updated_at INTEGER NOT NULL,
                parent_artifact_id TEXT,
                status TEXT NOT NULL DEFAULT 'complete',
                error_message TEXT,
                FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
                FOREIGN KEY (parent_artifact_id) REFERENCES artifacts(id) ON DELETE SET NULL
            );

            CREATE TABLE IF NOT EXISTS artifact_context (
                artifact_id TEXT NOT NULL,
                context_artifact_id TEXT NOT NULL,
                PRIMARY KEY (artifact_id, context_artifact_id),
                FOREIGN KEY (artifact_id) REFERENCES artifacts(id) ON DELETE CASCADE,
                FOREIGN KEY (context_artifact_id) REFERENCES artifacts(id) ON DELETE CASCADE
            );

            CREATE INDEX IF NOT EXISTS idx_artifacts_project ON artifacts(project_id);
            CREATE INDEX IF NOT EXISTS idx_artifacts_type ON artifacts(artifact_type);
            "#,
        )?;

        // Run migrations for existing databases
        Self::run_migrations(&conn)?;

        Ok(())
    }

    /// Run database migrations for schema changes.
    fn run_migrations(conn: &Connection) -> Result<()> {
        // Check if status column exists on artifacts, add if not
        let has_status: bool = conn
            .query_row(
                "SELECT COUNT(*) > 0 FROM pragma_table_info('artifacts') WHERE name = 'status'",
                [],
                |row| row.get(0),
            )
            .unwrap_or(false);

        if !has_status {
            conn.execute(
                "ALTER TABLE artifacts ADD COLUMN status TEXT NOT NULL DEFAULT 'complete'",
                [],
            )?;
            conn.execute("ALTER TABLE artifacts ADD COLUMN error_message TEXT", [])?;
        }

        // Check if session_id column exists on artifacts, add if not
        let has_session_id: bool = conn
            .query_row(
                "SELECT COUNT(*) > 0 FROM pragma_table_info('artifacts') WHERE name = 'session_id'",
                [],
                |row| row.get(0),
            )
            .unwrap_or(false);

        if !has_session_id {
            conn.execute("ALTER TABLE artifacts ADD COLUMN session_id TEXT", [])?;
        }

        Ok(())
    }

    // =========================================================================
    // Session operations
    // =========================================================================

    /// Create a new session
    pub fn create_session(&self, session: &Session) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "INSERT INTO sessions (id, working_dir, agent_id, title, created_at, updated_at)
             VALUES (?1, ?2, ?3, ?4, ?5, ?6)",
            params![
                &session.id,
                &session.working_dir,
                &session.agent_id,
                &session.title,
                session.created_at,
                session.updated_at,
            ],
        )?;
        Ok(())
    }

    /// Get a session by ID
    pub fn get_session(&self, id: &str) -> Result<Option<Session>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, working_dir, agent_id, title, created_at, updated_at
             FROM sessions WHERE id = ?1",
            params![id],
            |row| {
                Ok(Session {
                    id: row.get(0)?,
                    working_dir: row.get(1)?,
                    agent_id: row.get(2)?,
                    title: row.get(3)?,
                    created_at: row.get(4)?,
                    updated_at: row.get(5)?,
                })
            },
        )
        .optional()
        .map_err(Into::into)
    }

    /// List all sessions, ordered by most recently updated
    pub fn list_sessions(&self) -> Result<Vec<Session>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, working_dir, agent_id, title, created_at, updated_at
             FROM sessions ORDER BY updated_at DESC",
        )?;
        let sessions = stmt
            .query_map([], |row| {
                Ok(Session {
                    id: row.get(0)?,
                    working_dir: row.get(1)?,
                    agent_id: row.get(2)?,
                    title: row.get(3)?,
                    created_at: row.get(4)?,
                    updated_at: row.get(5)?,
                })
            })?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(sessions)
    }

    /// List sessions for a specific working directory
    pub fn list_sessions_for_dir(&self, working_dir: &str) -> Result<Vec<Session>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, working_dir, agent_id, title, created_at, updated_at
             FROM sessions WHERE working_dir = ?1 ORDER BY updated_at DESC",
        )?;
        let sessions = stmt
            .query_map(params![working_dir], |row| {
                Ok(Session {
                    id: row.get(0)?,
                    working_dir: row.get(1)?,
                    agent_id: row.get(2)?,
                    title: row.get(3)?,
                    created_at: row.get(4)?,
                    updated_at: row.get(5)?,
                })
            })?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(sessions)
    }

    /// Update session title
    pub fn update_session_title(&self, id: &str, title: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE sessions SET title = ?1, updated_at = ?2 WHERE id = ?3",
            params![title, now, id],
        )?;
        Ok(())
    }

    /// Touch session (update updated_at)
    pub fn touch_session(&self, id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE sessions SET updated_at = ?1 WHERE id = ?2",
            params![now, id],
        )?;
        Ok(())
    }

    /// Delete a session and all its messages
    pub fn delete_session(&self, id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute("DELETE FROM sessions WHERE id = ?1", params![id])?;
        Ok(())
    }

    // =========================================================================
    // Message operations
    // =========================================================================

    /// Add a message to a session, returns the message ID
    pub fn add_message(&self, session_id: &str, role: MessageRole, content: &str) -> Result<i64> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();

        conn.execute(
            "INSERT INTO messages (session_id, role, content, created_at)
             VALUES (?1, ?2, ?3, ?4)",
            params![session_id, role.as_str(), content, now],
        )?;

        let message_id = conn.last_insert_rowid();

        // Update session's updated_at
        conn.execute(
            "UPDATE sessions SET updated_at = ?1 WHERE id = ?2",
            params![now, session_id],
        )?;

        Ok(message_id)
    }

    /// Get all messages for a session
    pub fn get_messages(&self, session_id: &str) -> Result<Vec<Message>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, session_id, role, content, created_at
             FROM messages WHERE session_id = ?1 ORDER BY id ASC",
        )?;
        let messages = stmt
            .query_map(params![session_id], |row| {
                let role_str: String = row.get(2)?;
                Ok(Message {
                    id: row.get(0)?,
                    session_id: row.get(1)?,
                    role: MessageRole::parse(&role_str),
                    content: row.get(3)?,
                    created_at: row.get(4)?,
                })
            })?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(messages)
    }

    /// Get full session with all messages
    pub fn get_session_full(&self, id: &str) -> Result<Option<SessionFull>> {
        let session = match self.get_session(id)? {
            Some(s) => s,
            None => return Ok(None),
        };

        let messages = self.get_messages(id)?;
        Ok(Some(SessionFull { session, messages }))
    }

    /// Add an assistant turn with ordered segments (text + tool calls interleaved)
    pub fn add_assistant_turn(&self, session_id: &str, segments: &[ContentSegment]) -> Result<i64> {
        let content = serde_json::to_string(segments)?;
        self.add_message(session_id, MessageRole::Assistant, &content)
    }

    // =========================================================================
    // Project operations
    // =========================================================================

    /// Create a new project.
    pub fn create_project(&self, project: &Project) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "INSERT INTO projects (id, name, created_at, updated_at) VALUES (?1, ?2, ?3, ?4)",
            params![
                &project.id,
                &project.name,
                &project.created_at,
                &project.updated_at
            ],
        )?;
        Ok(())
    }

    /// Get a project by ID.
    pub fn get_project(&self, id: &str) -> Result<Option<Project>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, name, created_at, updated_at FROM projects WHERE id = ?1",
            params![id],
            |row| {
                Ok(Project {
                    id: row.get(0)?,
                    name: row.get(1)?,
                    created_at: row.get(2)?,
                    updated_at: row.get(3)?,
                })
            },
        )
        .optional()
        .map_err(Into::into)
    }

    /// List all projects, ordered by most recently updated.
    pub fn list_projects(&self) -> Result<Vec<Project>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, name, created_at, updated_at FROM projects ORDER BY updated_at DESC",
        )?;
        let projects = stmt
            .query_map([], |row| {
                Ok(Project {
                    id: row.get(0)?,
                    name: row.get(1)?,
                    created_at: row.get(2)?,
                    updated_at: row.get(3)?,
                })
            })?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(projects)
    }

    /// Update a project's name.
    pub fn update_project(&self, id: &str, name: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE projects SET name = ?1, updated_at = ?2 WHERE id = ?3",
            params![name, now, id],
        )?;
        Ok(())
    }

    /// Delete a project and all its artifacts.
    pub fn delete_project(&self, id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute("DELETE FROM projects WHERE id = ?1", params![id])?;
        Ok(())
    }

    // =========================================================================
    // Artifact operations
    // =========================================================================

    /// Create a new artifact.
    pub fn create_artifact(&self, artifact: &Artifact) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let data_json =
            serde_json::to_string(&artifact.data).map_err(|e| StoreError::new(e.to_string()))?;

        conn.execute(
            "INSERT INTO artifacts (id, project_id, title, artifact_type, data_json, created_at, updated_at, parent_artifact_id, status, error_message, session_id)
             VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)",
            params![
                &artifact.id,
                &artifact.project_id,
                &artifact.title,
                artifact.artifact_type().as_str(),
                data_json,
                &artifact.created_at,
                &artifact.updated_at,
                &artifact.parent_artifact_id,
                artifact.status.as_str(),
                &artifact.error_message,
                &artifact.session_id,
            ],
        )?;

        // Update the project's updated_at timestamp
        let now = now_timestamp();
        conn.execute(
            "UPDATE projects SET updated_at = ?1 WHERE id = ?2",
            params![now, &artifact.project_id],
        )?;

        Ok(())
    }

    /// Get an artifact by ID.
    pub fn get_artifact(&self, id: &str) -> Result<Option<Artifact>> {
        let conn = self.conn.lock().unwrap();
        conn.query_row(
            "SELECT id, project_id, title, data_json, created_at, updated_at, parent_artifact_id, status, error_message, session_id
             FROM artifacts WHERE id = ?1",
            params![id],
            |row| {
                let data_json: String = row.get(3)?;
                let data: ArtifactData = serde_json::from_str(&data_json).map_err(|e| {
                    rusqlite::Error::FromSqlConversionFailure(
                        3,
                        rusqlite::types::Type::Text,
                        Box::new(e),
                    )
                })?;
                let status_str: String = row.get(7)?;
                Ok(Artifact {
                    id: row.get(0)?,
                    project_id: row.get(1)?,
                    title: row.get(2)?,
                    created_at: row.get(4)?,
                    updated_at: row.get(5)?,
                    parent_artifact_id: row.get(6)?,
                    data,
                    status: ArtifactStatus::parse(&status_str),
                    error_message: row.get(8)?,
                    session_id: row.get(9)?,
                })
            },
        )
        .optional()
        .map_err(Into::into)
    }

    /// List artifacts in a project, ordered by most recently updated.
    pub fn list_artifacts(&self, project_id: &str) -> Result<Vec<Artifact>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, project_id, title, data_json, created_at, updated_at, parent_artifact_id, status, error_message, session_id
             FROM artifacts WHERE project_id = ?1 ORDER BY updated_at DESC",
        )?;
        let artifacts = stmt
            .query_map(params![project_id], |row| {
                let data_json: String = row.get(3)?;
                let data: ArtifactData = serde_json::from_str(&data_json).map_err(|e| {
                    rusqlite::Error::FromSqlConversionFailure(
                        3,
                        rusqlite::types::Type::Text,
                        Box::new(e),
                    )
                })?;
                let status_str: String = row.get(7)?;
                Ok(Artifact {
                    id: row.get(0)?,
                    project_id: row.get(1)?,
                    title: row.get(2)?,
                    created_at: row.get(4)?,
                    updated_at: row.get(5)?,
                    parent_artifact_id: row.get(6)?,
                    data,
                    status: ArtifactStatus::parse(&status_str),
                    error_message: row.get(8)?,
                    session_id: row.get(9)?,
                })
            })?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(artifacts)
    }

    /// List artifacts by type in a project.
    #[allow(dead_code)]
    pub fn list_artifacts_by_type(
        &self,
        project_id: &str,
        artifact_type: ArtifactType,
    ) -> Result<Vec<Artifact>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn.prepare(
            "SELECT id, project_id, title, data_json, created_at, updated_at, parent_artifact_id, status, error_message, session_id
             FROM artifacts WHERE project_id = ?1 AND artifact_type = ?2 ORDER BY updated_at DESC",
        )?;
        let artifacts = stmt
            .query_map(params![project_id, artifact_type.as_str()], |row| {
                let data_json: String = row.get(3)?;
                let data: ArtifactData = serde_json::from_str(&data_json).map_err(|e| {
                    rusqlite::Error::FromSqlConversionFailure(
                        3,
                        rusqlite::types::Type::Text,
                        Box::new(e),
                    )
                })?;
                let status_str: String = row.get(7)?;
                Ok(Artifact {
                    id: row.get(0)?,
                    project_id: row.get(1)?,
                    title: row.get(2)?,
                    created_at: row.get(4)?,
                    updated_at: row.get(5)?,
                    parent_artifact_id: row.get(6)?,
                    data,
                    status: ArtifactStatus::parse(&status_str),
                    error_message: row.get(8)?,
                    session_id: row.get(9)?,
                })
            })?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(artifacts)
    }

    /// Update an artifact's title and/or content.
    pub fn update_artifact(
        &self,
        id: &str,
        title: Option<&str>,
        data: Option<&ArtifactData>,
    ) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();

        match (title, data) {
            (Some(title), Some(data)) => {
                let data_json =
                    serde_json::to_string(data).map_err(|e| StoreError::new(e.to_string()))?;
                conn.execute(
                    "UPDATE artifacts SET title = ?1, data_json = ?2, artifact_type = ?3, updated_at = ?4 WHERE id = ?5",
                    params![title, data_json, data.artifact_type().as_str(), now, id],
                )?;
            }
            (Some(title), None) => {
                conn.execute(
                    "UPDATE artifacts SET title = ?1, updated_at = ?2 WHERE id = ?3",
                    params![title, now, id],
                )?;
            }
            (None, Some(data)) => {
                let data_json =
                    serde_json::to_string(data).map_err(|e| StoreError::new(e.to_string()))?;
                conn.execute(
                    "UPDATE artifacts SET data_json = ?1, artifact_type = ?2, updated_at = ?3 WHERE id = ?4",
                    params![data_json, data.artifact_type().as_str(), now, id],
                )?;
            }
            (None, None) => {
                return Ok(());
            }
        }

        // Update the project's updated_at timestamp
        conn.execute(
            "UPDATE projects SET updated_at = ?1 WHERE id = (SELECT project_id FROM artifacts WHERE id = ?2)",
            params![now, id],
        )?;

        Ok(())
    }

    /// Update an artifact's status (and optionally content/title).
    pub fn update_artifact_status(
        &self,
        id: &str,
        status: ArtifactStatus,
        error_message: Option<&str>,
        title: Option<&str>,
        data: Option<&ArtifactData>,
    ) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();

        match (title, data) {
            (Some(title), Some(data)) => {
                let data_json =
                    serde_json::to_string(data).map_err(|e| StoreError::new(e.to_string()))?;
                conn.execute(
                    "UPDATE artifacts SET status = ?1, error_message = ?2, title = ?3, data_json = ?4, artifact_type = ?5, updated_at = ?6 WHERE id = ?7",
                    params![status.as_str(), error_message, title, data_json, data.artifact_type().as_str(), now, id],
                )?;
            }
            (Some(title), None) => {
                conn.execute(
                    "UPDATE artifacts SET status = ?1, error_message = ?2, title = ?3, updated_at = ?4 WHERE id = ?5",
                    params![status.as_str(), error_message, title, now, id],
                )?;
            }
            (None, Some(data)) => {
                let data_json =
                    serde_json::to_string(data).map_err(|e| StoreError::new(e.to_string()))?;
                conn.execute(
                    "UPDATE artifacts SET status = ?1, error_message = ?2, data_json = ?3, artifact_type = ?4, updated_at = ?5 WHERE id = ?6",
                    params![status.as_str(), error_message, data_json, data.artifact_type().as_str(), now, id],
                )?;
            }
            (None, None) => {
                conn.execute(
                    "UPDATE artifacts SET status = ?1, error_message = ?2, updated_at = ?3 WHERE id = ?4",
                    params![status.as_str(), error_message, now, id],
                )?;
            }
        }

        Ok(())
    }

    /// Delete an artifact.
    pub fn delete_artifact(&self, id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute("DELETE FROM artifacts WHERE id = ?1", params![id])?;
        Ok(())
    }

    /// Set the session ID for an artifact.
    pub fn set_artifact_session(&self, artifact_id: &str, session_id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        let now = now_timestamp();
        conn.execute(
            "UPDATE artifacts SET session_id = ?1, updated_at = ?2 WHERE id = ?3",
            params![session_id, now, artifact_id],
        )?;
        Ok(())
    }

    // =========================================================================
    // Context operations
    // =========================================================================

    /// Add a context link (artifact X was created using artifact Y as context).
    pub fn add_context(&self, artifact_id: &str, context_artifact_id: &str) -> Result<()> {
        let conn = self.conn.lock().unwrap();
        conn.execute(
            "INSERT OR IGNORE INTO artifact_context (artifact_id, context_artifact_id) VALUES (?1, ?2)",
            params![artifact_id, context_artifact_id],
        )?;
        Ok(())
    }

    /// Get the artifacts that were used as context when creating an artifact.
    pub fn get_context_artifacts(&self, artifact_id: &str) -> Result<Vec<String>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn
            .prepare("SELECT context_artifact_id FROM artifact_context WHERE artifact_id = ?1")?;
        let ids = stmt
            .query_map(params![artifact_id], |row| row.get(0))?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(ids)
    }

    /// Get the artifacts that use this artifact as context.
    #[allow(dead_code)]
    pub fn get_dependent_artifacts(&self, context_artifact_id: &str) -> Result<Vec<String>> {
        let conn = self.conn.lock().unwrap();
        let mut stmt = conn
            .prepare("SELECT artifact_id FROM artifact_context WHERE context_artifact_id = ?1")?;
        let ids = stmt
            .query_map(params![context_artifact_id], |row| row.get(0))?
            .collect::<std::result::Result<Vec<_>, _>>()?;
        Ok(ids)
    }
}

// =============================================================================
// Helpers
// =============================================================================

/// Get current timestamp in milliseconds
pub fn now_timestamp() -> i64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis() as i64
}

/// Generate a unique session ID
pub fn generate_session_id() -> String {
    let timestamp = now_timestamp();
    static COUNTER: std::sync::atomic::AtomicU32 = std::sync::atomic::AtomicU32::new(0);
    let count = COUNTER.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
    format!("session_{:x}_{:x}", timestamp, count)
}

// =============================================================================
// Global Store
// =============================================================================

use std::sync::OnceLock;
use tauri::{AppHandle, Manager};

/// Global store instance - initialized during app setup.
static STORE: OnceLock<std::result::Result<Store, String>> = OnceLock::new();

/// Initialize the global store with the app's data directory.
/// Call this once during Tauri app setup.
pub fn init_store(app_handle: &AppHandle) -> Result<()> {
    let app_data_dir = app_handle
        .path()
        .app_data_dir()
        .map_err(|e| StoreError::new(format!("Cannot get app data dir: {}", e)))?;

    let db_path = app_data_dir.join("data.db");

    STORE.get_or_init(|| Store::open(db_path).map_err(|e| e.0));

    // Check if initialization succeeded
    get_store()?;
    Ok(())
}

/// Get the global store. Must call init_store first during app setup.
pub fn get_store() -> Result<&'static Store> {
    let result = STORE
        .get()
        .ok_or_else(|| StoreError::new("Store not initialized"))?;

    match result {
        Ok(store) => Ok(store),
        Err(msg) => Err(StoreError::new(msg.clone())),
    }
}

// =============================================================================
// Tests
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_create_and_get_session() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let now = now_timestamp();
        let session = Session {
            id: "test-session".to_string(),
            working_dir: "/tmp/repo".to_string(),
            agent_id: "goose".to_string(),
            title: Some("Test Session".to_string()),
            created_at: now,
            updated_at: now,
        };

        store.create_session(&session).unwrap();
        let retrieved = store.get_session("test-session").unwrap().unwrap();

        assert_eq!(retrieved.id, "test-session");
        assert_eq!(retrieved.title, Some("Test Session".to_string()));
    }

    #[test]
    fn test_add_and_get_messages() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let now = now_timestamp();
        let session = Session {
            id: "test-session".to_string(),
            working_dir: "/tmp/repo".to_string(),
            agent_id: "goose".to_string(),
            title: None,
            created_at: now,
            updated_at: now,
        };
        store.create_session(&session).unwrap();

        store
            .add_message("test-session", MessageRole::User, "Hello")
            .unwrap();
        store
            .add_message("test-session", MessageRole::Assistant, "Hi there!")
            .unwrap();

        let messages = store.get_messages("test-session").unwrap();
        assert_eq!(messages.len(), 2);
        assert_eq!(messages[0].role, MessageRole::User);
        assert_eq!(messages[0].content, "Hello");
        assert_eq!(messages[1].role, MessageRole::Assistant);
    }

    #[test]
    fn test_assistant_segments() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let now = now_timestamp();
        let session = Session {
            id: "test-session".to_string(),
            working_dir: "/tmp/repo".to_string(),
            agent_id: "goose".to_string(),
            title: None,
            created_at: now,
            updated_at: now,
        };
        store.create_session(&session).unwrap();

        let segments = vec![
            ContentSegment::Text {
                text: "Let me read that file.".to_string(),
            },
            ContentSegment::ToolCall {
                id: "tc1".to_string(),
                title: "Read file".to_string(),
                status: "completed".to_string(),
                locations: vec!["src/main.rs".to_string()],
            },
            ContentSegment::Text {
                text: "Here's what I found.".to_string(),
            },
        ];

        store
            .add_message("test-session", MessageRole::User, "Read main.rs")
            .unwrap();
        store.add_assistant_turn("test-session", &segments).unwrap();

        let full = store.get_session_full("test-session").unwrap().unwrap();
        assert_eq!(full.messages.len(), 2);

        let loaded_segments: Vec<ContentSegment> =
            serde_json::from_str(&full.messages[1].content).unwrap();
        assert_eq!(loaded_segments.len(), 3);
    }

    #[test]
    fn test_delete_session_cascades() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let now = now_timestamp();
        let session = Session {
            id: "test-session".to_string(),
            working_dir: "/tmp/repo".to_string(),
            agent_id: "goose".to_string(),
            title: None,
            created_at: now,
            updated_at: now,
        };
        store.create_session(&session).unwrap();
        store
            .add_message("test-session", MessageRole::User, "Hello")
            .unwrap();

        store.delete_session("test-session").unwrap();

        let retrieved = store.get_session("test-session").unwrap();
        assert!(retrieved.is_none());

        let messages = store.get_messages("test-session").unwrap();
        assert!(messages.is_empty());
    }

    #[test]
    fn test_create_and_get_project() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let project = Project::new("Test Project");

        store.create_project(&project).unwrap();
        let retrieved = store.get_project(&project.id).unwrap().unwrap();

        assert_eq!(retrieved.id, project.id);
        assert_eq!(retrieved.name, "Test Project");
    }

    #[test]
    fn test_create_and_get_artifact() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let project = Project::new("Test Project");
        store.create_project(&project).unwrap();

        let artifact = Artifact::new_markdown(&project.id, "Test Artifact", "# Hello\n\nWorld");
        store.create_artifact(&artifact).unwrap();

        let retrieved = store.get_artifact(&artifact.id).unwrap().unwrap();
        assert_eq!(retrieved.id, artifact.id);
        assert_eq!(retrieved.title, "Test Artifact");

        if let ArtifactData::Markdown { content } = &retrieved.data {
            assert_eq!(content, "# Hello\n\nWorld");
        } else {
            panic!("Expected markdown artifact");
        }
    }

    #[test]
    fn test_delete_project_cascades() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let project = Project::new("Test Project");
        store.create_project(&project).unwrap();

        let artifact = Artifact::new_markdown(&project.id, "Test", "Content");
        store.create_artifact(&artifact).unwrap();

        store.delete_project(&project.id).unwrap();

        let retrieved = store.get_artifact(&artifact.id).unwrap();
        assert!(retrieved.is_none());
    }

    #[test]
    fn test_context_links() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let store = Store::open(db_path).unwrap();

        let project = Project::new("Test Project");
        store.create_project(&project).unwrap();

        let a1 = Artifact::new_markdown(&project.id, "Research", "Research content");
        let a2 = Artifact::new_markdown(&project.id, "Plan", "Plan based on research");

        store.create_artifact(&a1).unwrap();
        store.create_artifact(&a2).unwrap();

        store.add_context(&a2.id, &a1.id).unwrap();

        let context = store.get_context_artifacts(&a2.id).unwrap();
        assert_eq!(context, vec![a1.id.clone()]);

        let dependents = store.get_dependent_artifacts(&a1.id).unwrap();
        assert_eq!(dependents, vec![a2.id.clone()]);
    }
}
